package csvd

import (
	"encoding/csv"
	"sort"
	"strings"
)

// Sniffer works on the CSV file to detect its delimiter.
type Sniffer struct {
	sampleSize   int
	delimiter    rune
	frequencyMap frequencyMap
}

// DefaultSniffer returns the default Sniffer.
func defaultSniffer() *Sniffer {
	return NewSniffer(15, ',', '\t', ';', ':', '|')
}

// NewSniffer creates a new Sniffer struct. It can be provded with a sampleSize int which
// tells the sniffer how many rows to look at, and a list of rune delimiters.
func NewSniffer(sampleSize int, delims ...rune) *Sniffer {
	delimiterMap := frequencyMap{}

	for _, d := range delims {
		delimiterMap[d] = map[int]int{}
	}

	return &Sniffer{
		sampleSize:   15,
		delimiter:    ',',
		frequencyMap: delimiterMap,
	}
}

// Samples the first few lines, and tries to split on each delimiter. It counts the length of the split
// and how often it occurs. This is then used to guess the delimiter.
func (s *Sniffer) analyse(r *csv.Reader) rune {
	for i := 0; i < s.sampleSize; i++ {
		line, err := r.Read()
		if err != nil {
			break
		}
		if len(line) > 1 {
			s.increment(r.Comma, len(line))
			continue
		}

		for potential := range s.frequencyMap {
			split := strings.Split(strings.TrimSpace(line[0]), string(potential))
			s.increment(potential, len(split))
		}
	}

	return s.sniff()
}

// Create dialects by looking at the frequency map generated by analyse. Then sort them into the most
// likely one and return its delimiter.
func (s *Sniffer) sniff() rune {
	ds := dialects{}
	for potential := range s.frequencyMap {
		p := dialect{
			delimiter:  potential,
			likelihood: []float64{},
		}
		for split, occurences := range s.frequencyMap[potential] {
			p.likelihood = append(p.likelihood, float64(split)/float64(occurences))
		}
		if len(p.likelihood) != 0 {
			sort.Float64s(p.likelihood)
			ds = append(ds, p)
		}
	}
	sort.Sort(ds)
	if len(ds) == 0 {
		return ','
	}
	s.delimiter = ds[0].delimiter
	return s.delimiter
}

func (s *Sniffer) increment(r rune, amount int) {
	_, ok := s.frequencyMap[r][amount]
	if !ok {
		s.frequencyMap[r][amount] = 0
	}
	s.frequencyMap[r][amount]++
}
