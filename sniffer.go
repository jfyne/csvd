package csvd

import (
	"encoding/csv"
	"sort"
	"strings"
)

type sniffer struct {
	sampleSize   int
	delimiter    rune
	frequencyMap frequencyMap
}

func newSniffer() *sniffer {
	delims := frequencyMap{
		',':  {},
		'\t': {},
		';':  {},
		':':  {},
	}

	return &sniffer{
		sampleSize:   15,
		delimiter:    ',',
		frequencyMap: delims,
	}
}

// Samples the first few lines, and tries to split on each delimiter. It counts the length of the split
// and how often it occurs. This is then used to guess the delimiter.
func (s *sniffer) analyse(r *csv.Reader) rune {
	for i := 0; i < s.sampleSize; i++ {
		line, err := r.Read()
		if err != nil {
			break
		}
		if len(line) > 1 {
			s.increment(r.Comma, len(line))
			continue
		}

		for potential := range s.frequencyMap {
			split := strings.Split(strings.TrimSpace(line[0]), string(potential))
			s.increment(potential, len(split))
		}
	}

	return s.sniff()
}

// Create dialects by looking at the frequency map generated by analyse. Then sort them into the most
// likely one and return its delimiter.
func (s *sniffer) sniff() rune {
	ds := dialects{}
	for potential := range s.frequencyMap {
		p := dialect{
			delimiter:  potential,
			likelihood: []float64{},
		}
		for split, occurences := range s.frequencyMap[potential] {
			p.likelihood = append(p.likelihood, float64(split)/float64(occurences))
		}
		if len(p.likelihood) != 0 {
			sort.Float64s(p.likelihood)
			ds = append(ds, p)
		}
	}
	sort.Sort(ds)
	s.delimiter = ds[0].delimiter
	return s.delimiter
}

func (s *sniffer) increment(r rune, amount int) {
	_, ok := s.frequencyMap[r][amount]
	if !ok {
		s.frequencyMap[r][amount] = 0
	}
	s.frequencyMap[r][amount]++
}
